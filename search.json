[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Zhaose, an undergraduate student studying physcis at ECNU (East China Normal University), who is interested in Quantum Field Theory and Elementary Particle Physics.\nThis blog is mainly focused on posting small calculations and projects about physcis."
  },
  {
    "objectID": "posts/LatticeHarmonicOscillator/index.html",
    "href": "posts/LatticeHarmonicOscillator/index.html",
    "title": "Simulating Harmonic Oscillator on a Lattice",
    "section": "",
    "text": "Concepts\nFor a harmonic oscillator, the lagrangian can be written as: \nL = \\frac{1}{2} m \\dot{x}^2 - \\frac{1}{2} m \\omega^2 x^2\n The two-point correlation function then, is \nD_q(t_1, t_2) = \\bra{q, T} \\mathbf{x}(t_2) \\mathbf{x}(t_1) \\ket{q, 0}\n If we transfer it into Shördinger picture, and insert sets of energy eigenstates, we have \n\\begin{align*}\n& \\bra{q, T} \\mathbf{x}(t_2) \\mathbf{x}(t_1) \\ket{q, 0} \\\\\n=& \\bra{q} e^{-i \\mathbf{H} (T - t_2)} \\mathbf{x} e^{-i \\mathbf{H} (t_2 - t_1)} \\mathbf{x} e^{-i \\mathbf{H} t_1} \\ket{q} \\\\\n=& \\sum_{a,b,c,d} \\bra{q} e^{-i \\mathbf{H} (T - t_2)} \\ket{a} \\bra{a} \\mathbf{x} \\ket{b} \\bra{b} e^{-i \\mathbf{H}(t_2 - t_1)}  \\ket{c} \\bra{c} \\mathbf{x} \\ket{d} \\bra{d} e^{-i \\mathbf{H} t_1} \\ket{q} \\\\\n=& \\sum_{a,b,d} e^{-i H_a (T - t_2)} e^{-i H_d t_1} e^{-i H_b (t_2 - t_1)} \\braket{d|q} \\braket{q|a} \\braket{a|\\mathbf{x}|b} \\braket{b|\\mathbf{x}|d}\n\\end{align*}\n It kinda looks like a mess. However, when we do simulation, we always impose the periodic boundary, so we should also do it here, then we have \n\\begin{align*}\n=& \\int dq \\sum_{a,b,d} e^{-i H_a (T - t_2)} e^{-i H_d t_1} e^{-i H_b (t_2 - t_1)} \\braket{d|q} \\braket{q|a} \\braket{a|\\mathbf{x}|b} \\braket{b|\\mathbf{x}|d} \\\\\n=& \\sum_{a,b} e^{-i H_a (T - t_2 + t_1)} e^{-i H_b (t_2 - t_1)} \\braket{a|\\mathbf{x}|b} \\braket{b|\\mathbf{x}|d} \\\\\n=& \\sum_{a,b} e^{-i H_a (T - \\Delta t)} e^{-i H_b \\Delta t} \\left|\\braket{0|\\mathbf{x}|1}\\right|^2 \\\\\n\\end{align*}\n Here we just be aware of that different energy eigenstates are orthogonal. To keeps things simple, if we only consider the leading term, which is a,b = 0,1, then we have \n\\begin{align*}\n=& \\int dq \\bra{q, T} \\mathbf{x}(t_2) \\mathbf{x}(t_1) \\ket{q, 0} \\\\\n=& e^{-i H_0 T} \\left|\\braket{0|\\mathbf{x}|1}\\right|^2 (e^{-i \\Delta H \\Delta t} + e^{-i \\Delta H (T - \\Delta t)})\n\\end{align*}\n Since the expectation of \\mathbf{x} is zero, some terms vanish. Note that the only non-constant here is \\Delta t, which means \n\\int_{PB} Dx(t) \\; x(t_1) x(t_2) exp\\{i \\int dt L \\} \\\\\n\\propto e^{-i \\Delta H \\Delta t} + e^{-i \\Delta H (T - \\Delta t)}\n Let t \\to -i \\tau, then we have \n\\int_{PB} Dx(\\tau) \\; x(\\tau_1) x(\\tau_2) exp\\{- \\int d\\tau L_E \\} \\\\\n\\propto e^{- \\Delta H \\Delta \\tau} + e^{- \\Delta H (\\Tau - \\Delta \\tau)}\n\\tag{1} Here \nL_E = \\frac{1}{2} m (\\frac{dx}{d\\tau})^2 + \\frac{1}{2} m \\omega^2 x^2\n\\tag{2}\n\n\nSimulation\nIf we can write some code to calculate Equation 1, then we can extract \\Delta H from it, by addressing its relation with \\Delta \\tau. Calculating such a path-integral may seem to be impossible, however, doing MC simulation, we first simply generate a lot of “paths”, make sure their weight is proportional to exp\\{-S_E\\}, then perform measurements on those paths, get the mean of all measurements, then we will have the approximation of Equation 1.\nFirst, make our x dimension-free might be a good idea, although it’s not necessary here. \nx = a \\hat{x} \\to \\hat{\\omega} = \\omega \\times a\n Then define a struct to hold all essential variables, write the function to calculate the change of action after imposing a perturbation at x(\\tau)\n\n\nCode\nusing Pkg\nPkg.add(\"Plots\")\n\n\n\n\nCode\nusing Base.Threads\nusing Random\nusing Plots\n\nstruct World\n  xs::Vector{Float64}\n  lt::Int\n  m::Float64\n  ω::Float64\n  pt::Float64\n  rb::Vector{Any}\nend\n\nfunction gen_world(lt, m, ω, pt)\n  red_t = filter(isodd, 1:lt)\n  black_t = filter(iseven, 1:lt)\n  return World(zeros(lt), lt, m, ω, pt, [red_t, black_t])\nend\n\nfunction get_action_diff(w, t, new_x)\n  lt = w.lt\n  old_x = w.xs[t]\n\n  act_diff = 0.5 * w.m * w.ω^2 * (new_x^2 - old_x^2)\n  for t_nb in mod1.((t-1, t+1), lt)\n    act_diff += 0.5 * w.m * (new_x - old_x) * (new_x + old_x - 2 * w.xs[t_nb])\n  end\n\n  return act_diff\nend\n\n\nHere we separate points in to groups so we can update each group in parallel. Then is how to update the path.\n\n\nCode\nfunction update_xs!(w, t)\n  new_x = w.xs[t] + (rand() - 0.5) * 2 * w.pt\n  \n  act_diff = get_action_diff(w, t, new_x)\n  if act_diff &gt;= 0\n    if exp(- act_diff) &lt; rand()\n      return false\n    end\n  end\n\n  w.xs[t] = new_x\n  return true\nend\n\nfunction sweep_w!(w; save_accept=false)\n  accepts = Atomic{Int}(0)\n  @threads for t in w.rb[1]\n    acc = update_xs!(w, t)\n    if save_accept\n      atomic_add!(accepts, Int(acc))\n    end\n  end\n  @threads for t in w.rb[2]\n    acc = update_xs!(w, t)\n    if save_accept\n      atomic_add!(accepts, Int(acc))\n    end\n  end\n  return accepts[] / w.lt\nend\n\n\nHere exp(- act_diff) &lt; rand() make sure that the weight is properly generated. However, when running the simulation, we need to tune how much perturbtion is made each time, to keep the accept rate to about 1/2.\nAnd to measure, we iterate all path points and take the mean, for each \\Delta t\n\n\nCode\nfunction measure_x2(w)\n  x2_t = zeros(w.lt)\n  for t_0 in 1:w.lt\n    @threads for Δt in 0:(w.lt - 1)\n      x2_t[Δt + 1] += w.xs[t_0] * w.xs[mod1(t_0 + Δt, w.lt)]\n    end\n  end\n  x2_t = x2_t ./ w.lt\n  return x2_t\nend\n\n\nNow the only thing left is to run the simulation and compare the result with our theoretical result, Equation 1.\n\n\nCode\nw = gen_world(100, 1.0, 1.0 * 0.1, 2.0)\n\nn_heat = 1000\nprintln(\"HEATING...\")\nacc = 0\nfor i in 1:n_heat\n  acc += sweep_w!(w; save_accept=true)\nend\nprintln(\"ACCEPTED RATE: $(acc / n_heat)\")\n\nn_measure = 1000\n\nx2_t = zeros(w.lt)\nprintln(\"MEASURING...\")\nfor i in 1:n_measure\n  for j in 1:1000\n    sweep_w!(w)\n  end\n  x2_t .+= measure_x2(w)\nend\nx2_t ./= n_measure\npush!(x2_t, x2_t[1])\n\n\nAnalyze the result, we have\n\n\nCode\nx2_normed = x2_t ./ sum(x2_t) .* 10.0\n\nts = (0:(w.lt)) ./ 10.0\nfunction theo_fun(t)\n  norm = 2.0 - exp(-10.0)\n  return (exp(- 1.0 * t) + exp(- 1.0 * (10.0 - t))) / norm\nend\n\np1 = plot(ts , x2_normed, label = \"sim\", color = :black, xlabel = \"Time\", ylabel=\"Correlation\")\nplot!(p1, ts, theo_fun, color = :red, label=\"theo\", ls=:dash)\n\nx2_samp = x2_normed[1:15]\nt_samp  = ts[1:15]\np2 = plot(t_samp , log.(x2_samp), label = \"sim\", color = :black, xlabel = \"Time\", ylabel=\"ln(Correlation)\")\nplot!(p2, t_samp, (t) -&gt; log(theo_fun(t)), color = :red, label=\"theo\", ls=:dash)\n\nplot(p1, p2, size=(800,400))\n\n\n\n\n\nNote that only the slope in the second picture matters, which means it fits really well. So through this MC simulation, we can extract the difference between the first excited state and the groud state, which is \\hbar \\omega in this case. More uses can be seen in Lattice-QCD, etc."
  },
  {
    "objectID": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html",
    "href": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html",
    "title": "Renormalization of scalar propagator in a toy model",
    "section": "",
    "text": "Consider a mass-full scalar field \\phi coupling with a mass-less scalar field \\chi, the toy model’s total Lagrangian can be written as: \n\\mathcal{L}_B = \\partial_\\mu \\phi^* \\, \\partial^\\mu \\phi - m^2\\phi^* \\phi + {1 \\over 2} \\partial_\\mu \\chi \\, \\partial^\\mu \\chi - \\lambda \\phi^* \\phi \\chi\n So we have Feynmann rules for those particles (in momentum space):\n\nVertex: - i \\lambda\n\\phi propagator: i\\over{p^2 - m^2 + i \\epsilon }\n\\chi propagator: i\\over{p^2 + i \\epsilon }\n\nNow we can consider a simple \\phi - \\phi scattering process:\n\n\n\nTree Level Feynmann Diagram\n\n\nThe scattering amplitude of this diagram is simple: \n\\mathcal{M}^{(0)} = - i {\\lambda^2 \\over q^2}\n This is an u-channel diagram, for this process, there is also a s-channel diagram, these two together make up the first order of this scattering process, however, for our topic today, it’s unrelated.\nThen consider the following high-order diagram, in which the \\chi particle breaks in to a pair of virtual \\phi and anti-\\phi particle.\n\n\n\n\\chi Loop Diagram\n\n\nThe amplitude of this new diagram is: \n\\mathcal{M}^{(1)} = {\\lambda^4 \\over q^4} \\int {d^4 k \\over (2\\pi)^4} {1 \\over {k^2 - m^2 + i \\epsilon}} {1 \\over {(k-q)^2 - m^2 + i \\epsilon}}\n One immediately sees this integral is divergent. The integral measure contains |k|^3, causes the result to diverge in the form of \\ln{|k|}, and this does not make any sense, since this diagram is meant to be a small correction of the first diagram we’ve already covered. Something needs to be done to get a reasonable answer.\nFurther investigation of there two amplitudes, one will notice the effect of the second diagram is just multiplying some factor on to the propagator of \\chi, which is: \nG_\\chi^{(1)}=G_\\chi^{(0)} \\, \\lambda^2 {i \\over q^2} \\, I(q)\n where \nI(q) = \\int {d^4 k \\over (2\\pi)^4} {1 \\over {k^2 - m^2 +i \\epsilon}} {1 \\over {(k-q)^2 - m^2 +i \\epsilon}}"
  },
  {
    "objectID": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#feynmann-factorize",
    "href": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#feynmann-factorize",
    "title": "Renormalization of scalar propagator in a toy model",
    "section": "Feynmann factorize",
    "text": "Feynmann factorize\nStart with rewriting the integral in a more manageable form, using the fact that: \n\\begin{align*}\n{1 \\over {A B}} &= \\int_0^1 dx {1 \\over {[x A + (1-x) B]^2}} \\\\\n&= \\int_0^1 dx \\int_0^1 dy \\: \\delta(x+y-1) \\, {1 \\over {[x A + y B]^2}}\n\\end{align*}\n The factorized denominator is: \n\\begin{align*}\nD &= x(k^2 - m^2 +i \\epsilon) + y[(k-q)^2 - m^2 +i \\epsilon] \\\\\n  &= k^2 - 2 y q k + y q^2 - m^2 + i \\epsilon \\\\\n  &= (k - yq)^2 + xyq^2 - m^2 + i \\epsilon \\\\\n  &= l^2 - \\Delta + i \\epsilon\n\\end{align*}\n In the third equal we’ve used x + y = 1. Finally by shifting k, which is just applying l = k - yq and \\Delta = - xyq^2 + m^2, the integral becomes: \n\\int {d^4 k \\over (2\\pi)^4} {1 \\over {k^2 - m^2 +i \\epsilon}} {1 \\over {(k-q)^2 - m^2 +i \\epsilon}} \\\\\n= \\int_0^1 dx \\int_0^1 dy \\: \\delta(x+y-1) \\, {1 \\over (2\\pi)^4} \\int {d^4 l} {1 \\over {(l^2 - \\Delta + i\\epsilon)^2}}"
  },
  {
    "objectID": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#wick-rotation",
    "href": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#wick-rotation",
    "title": "Renormalization of scalar propagator in a toy model",
    "section": "Wick rotation",
    "text": "Wick rotation\nThe integral is integrated over the 4-dimensional Minkowski space, which is tedious. However, one can apply Wick rotation to turn it in to a 4-dimensional Euclid space integral.\nFocus on the integral over l^0: \n\\int_{-\\infty}^{+\\infty}dl^0 {1 \\over {[(l^0)^2-|\\vec{l}|^2 - \\Delta + i \\epsilon]^2}}\n The integral is real. However, this integral can be considered as a integral in the complex plane, the contour is around the upper-half of the complex plane, since obviously at \\infty things in the integral turn into zero. So the value of this integral only depends on the residue of singularities involved, which in the upper-half only have l^0 = -\\sqrt{|\\vec{l}|^2+\\Delta} + i \\epsilon, so the contour can be rotated to the left-half of the plane, resulting in: \n\\int_{-i\\infty}^{+i\\infty}dl^0 {1 \\over {[(l^0)^2-|\\vec{l}|^2 - \\Delta + i \\epsilon]^2}}\n Then apply l^0 = i l^4: \n\\int_{-\\infty}^{+\\infty}dl^0 {1 \\over {[(l^0)^2-|\\vec{l}|^2 - \\Delta + i \\epsilon]^2}} = i \\int_{-\\infty}^{+\\infty}dl^4 {1 \\over {[- (l^4)^2 - |\\vec{l}|^2 - \\Delta + i \\epsilon]^2}}\n Integral over the 4-Minkowski now transforms into a 4-dimensional Euclid integral. The i\\epsilon is no longer necessary, since there are no singularities on the complex-axis: \n\\int {d^4 l} {1 \\over {(l^2 - \\Delta + i\\epsilon)^2}} = i \\int {d^4 \\bm{l_E}} {1 \\over {(\\bm{l_E}^2 + \\Delta )^2}}"
  },
  {
    "objectID": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#hard-cut-off",
    "href": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#hard-cut-off",
    "title": "Renormalization of scalar propagator in a toy model",
    "section": "Hard cut-off",
    "text": "Hard cut-off\nOne can calculate the integral by simply using the 4-dimensional spherical coordinate system, then apply a hard cut-off \\Lambda to l_E:： \n\\int {d^4 \\bm{l_E}} {1 \\over {(\\bm{l_E}^2 + \\Delta)^2}} =\\lim_{\\Lambda \\to + \\infty} \\int d\\Omega_4 \\int_{0}^{\\Lambda}dl_E {{l_E}^3 \\over {({l_E}^2 + \\Delta)^2}}\n By the way, this cut-off is Lorenz invariant, sinces it’s identical to a cut-off applied under Minkowski space. However, if one do the l^0 integral first then apply the cut-off, it’s not Lorenz invariant. Then this integral is trivial: \n\\begin{aligned}\n\\int_{0}^{\\Lambda}dl_E {{l_E}^3 \\over {({l_E}^2 + \\Delta)^2}} &= {1 \\over 2} \\int_{0}^{\\Lambda}d{l_E}^2 {{l_E}^2 \\over {({l_E}^2 + \\Delta)^2}} \\\\\n&= {1 \\over 2} \\int_{0}^{\\Lambda}d{l_E}^2 \\left[{1 \\over {{l_E}^2 + \\Delta}} - {\\Delta \\over {({l_E}^2 + \\Delta)^2}}\\right] \\\\\n&= {1 \\over 2} \\left( \\ln{{\\Lambda^2 + \\Delta} \\over \\Delta} - {\\Lambda^2 \\over \\Lambda^2  + \\Delta} \\right) \\\\\n&= {1 \\over 2} \\left( \\ln{{\\Lambda^2} \\over \\Delta(x,y,q^2)} - 1 \\right)\n\\end{aligned}\n Substitute all these result to the original inegral I(q) (Integral over d\\Omega_4 is 2 \\pi^2): \nI(q) = {i \\over 16 \\pi^2 } (\\ln{\\Lambda^2 \\over \\mu^2} - 1 - \\int_0^1dx \\ln{\\Delta \\over \\mu^2})\n \\mu is an arbitrary number has unit of mass, which keeps the inside of \\ln pure number, but actually it’s not necessary and won’t effect our final answer."
  },
  {
    "objectID": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#renormalized-chi-propagator",
    "href": "posts/RenormalizationOfScalarPropagatorInAToyModel/index.html#renormalized-chi-propagator",
    "title": "Renormalization of scalar propagator in a toy model",
    "section": "Renormalized \\chi propagator",
    "text": "Renormalized \\chi propagator\nTake account of other loop diagrams (loops are aligned along the \\chi propagator and do not have loops inside them), the total propagator of \\chi is: \nG_\\chi(q) = \\sum_{n=0}^{\\infty}G_\\chi^{(n)} ={i \\over q^2 - i \\lambda^2 I(q)}\n One will notice the divergent part of I(q), which is \\ln\\Lambda^2, does not depend on q. That means if we introduce the exact mass term into \\chi’s Lagrangian, the divergents cancels out: \n\\mathcal{L} = \\mathcal{L}_B - {1 \\over 2}M^2\\chi^2\n Where M = {\\lambda^2 \\over 16 \\pi^2} \\ln{\\Lambda^2 \\over \\mu^2} + M_0^2. The introduce of M_0 is for keeping the original propagator under q = 0 limit.\nSo the corrected propagator is: \nG_\\chi(q) = {i \\over q^2 - {\\lambda^2 \\over 16 \\pi^2}(\\int_0^1dx\\ln{\\Delta \\over \\mu^2}+1)+M_0^2}\n Apply constrain at G_\\chi(0) will allow us to get M_0^2 = {\\lambda^2 \\over 16 \\pi^2}(\\ln{m^2 \\over \\mu^2} + 1), then add back i\\epsilon: \nG_\\chi(q) = {i \\over q^2 - {\\lambda^2 \\over 16 \\pi^2}\\int_0^1dx\\ln(1-{x(1-x)q^2 \\over m^2}) + i\\epsilon}\n This is \\chi’s “absolute” propagator. There is a mass-like term depending on q^2, which indicates different behaviour under different energy.\nNow we’ve successfully solved the divergent introduced by the loop diagram, though -\\lambda\\phi\\phi^*\\chi vertex and \\phi propagator can also generate divergent, however they can be treated using the same manner. If we try to do this under QED, gamma matrixes and tensor algebra will be invoded, making it more tedious."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "All Posts",
    "section": "",
    "text": "Simulating Harmonic Oscillator on a Lattice\n\n\n\nphysics\n\ncomputational\n\npath-integral\n\nQM\n\n\n\n\n\n\n\n\n\nJan 18, 2026\n\n\nZhaose\n\n\n\n\n\n\n\n\n\n\n\n\nGravity With Portal\n\n\n\nphysics\n\ncomputational\n\nclassical\n\nfun\n\n\n\n\n\n\n\n\n\nDec 16, 2025\n\n\nZhaose\n\n\n\n\n\n\n\n\n\n\n\n\nAxion-photon Compton Scattering\n\n\n\nphysics\n\nQFT\n\n\n\n\n\n\n\n\n\nNov 29, 2025\n\n\nZhaose\n\n\n\n\n\n\n\n\n\n\n\n\nRenormalization of scalar propagator in a toy model\n\n\n\nphysics\n\nQFT\n\n\n\n\n\n\n\n\n\nOct 21, 2025\n\n\nZhaose\n\n\n\n\n\n\n\n\n\n\n\n\nBorn approximation from path integral\n\n\n\nphysics\n\nQM\n\n\n\n\n\n\n\n\n\nJul 31, 2025\n\n\nZhaose\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/AxionPhotonComptonScattering/index.html",
    "href": "posts/AxionPhotonComptonScattering/index.html",
    "title": "Axion-photon Compton Scattering",
    "section": "",
    "text": "The effective axion-photon lagrangian can be written as: \n\\mathcal{L}_{\\alpha\\gamma} = (\\frac{1}{2} \\partial_\\mu a \\, \\partial^\\mu a - \\frac{1}{2}m^2 a^2)\n+ (-\\frac{1}{4} F_{\\mu\\nu} F^{\\mu\\nu}) - \\frac{1}{4} g \\, a \\, F_{\\mu\\nu} \\tilde{F}^{\\mu\\nu}\n Here \\tilde{F}^{\\mu\\nu} = \\frac{1}{2}\\epsilon^{\\mu\\nu\\rho\\sigma}F_{\\rho\\sigma} is the dual of F^{\\mu\\nu}. Focus on the interaction term, break F^{\\mu\\nu} out, we have: \n\\begin{align*}\n-\\frac{1}{4} g \\, a \\, F_{\\mu\\nu} \\tilde{F}^{\\mu\\nu} &=\n-\\frac{1}{8} g \\, a (\\partial_\\mu A_\\nu - \\partial_\\nu A_\\mu)\n\\epsilon^{\\mu\\nu\\rho\\sigma} (\\partial_\\rho A_\\sigma - \\partial_\\sigma A_\\rho) \\\\\n&= - \\frac{1}{2} g \\, a \\epsilon^{\\mu\\nu\\rho\\sigma} \\partial_\\mu A^\\nu \\partial_\\rho A^\\sigma\n\\end{align*}\n Then we get the interaction vertex in the form of (in momentum space): \ni g \\epsilon^{\\mu\\nu\\rho\\sigma} k^{(1)}_\\mu k^{(2)}_\\rho\n Here k^{(1,2)} are the momentum of incoming and outcoming photons, amoung k^{(1)} and k^{(2)}, one flows into the vertex and and the other one flows out. Now recall the propagator of scalar particles and photons, we have:\n\nAxion propagator: \\frac{i}{k^2 - m^2 + i \\epsilon}\nPhoton propagator: \\frac{i \\eta_{\\mu\\nu}}{k^2 + i \\epsilon}\n\n\n\n\nFor the lowest order of photon-axion Compton-like scattering, only two Feynman diagrams contribute, one s-channel and one u-channel:\n \nand we can write: \n\\begin{align*}\n  i\\mathcal{M}_s &= \\epsilon^{\\gamma}_{\\nu}(k) \\left( i g \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu (k+p)_\\alpha\n  \\right) \\frac{i \\eta_{\\beta\\lambda}}{(k+p)^2} \\left( i g \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  (k'+p')_\\delta k'_\\rho \\right) \\epsilon^{\\gamma'}_{\\sigma}(k') \\\\\n  \\mathcal{M}_s &= - \\frac{g^2}{(k+p)^2} \\epsilon^{\\gamma}_{\\nu}(k) \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu p_\\alpha\n   \\eta_{\\beta\\lambda} \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  p'_\\delta k'_\\rho \\epsilon^{\\gamma'}_{\\sigma}(k')\n\\end{align*}\n along with: \n\\begin{align*}\n  i\\mathcal{M}_u &= \\epsilon^{\\gamma}_{\\nu}(k) \\left( i g \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu (k-p')_\\alpha\n  \\right) \\frac{i \\eta_{\\beta\\lambda}}{(k-p')^2} \\left( i g \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  (k'-p)_\\delta k'_\\rho \\right) \\epsilon^{\\gamma'}_{\\sigma}(k') \\\\\n  \\mathcal{M}_u &= - \\frac{g^2}{(k-p')^2} \\epsilon^{\\gamma}_{\\nu}(k) \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu p'_\\alpha\n   \\eta_{\\beta\\lambda} \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  p_\\delta k'_\\rho \\epsilon^{\\gamma'}_{\\sigma}(k')\n\\end{align*}\n Then the total scattering amplitude is: \n\\begin{align*}\n\\mathcal{M} &= \\mathcal{M}_s + \\mathcal{M}_u \\\\\n&=\n- g^2 \\epsilon^{\\gamma}_{\\nu}(k) k_{\\mu} \\left( \\frac{p_\\alpha p'_\\delta}{(k+p)^2} + \\frac{p'_\\alpha p_\\delta}{(k-p')^2}\n\\right) k'_{\\rho} \\epsilon^{\\gamma'}_{\\sigma}\n(\\epsilon^{\\beta\\mu\\nu\\alpha} \\eta_{\\beta\\lambda} \\epsilon^{\\lambda\\delta\\rho\\sigma})\n\\end{align*}\n Contract and simplify this impossible expression by FORM script and complete spin sum, we can finally get: \n\\left| \\mathcal{M} \\right|^2_{all} = g^4 \\left\\{ \\frac{m^8}{16}(\\frac{1}{s} + \\frac{1}{u})^2\n- \\frac{m^4}{8}(\\frac{u}{s} + \\frac{s}{u} - 6) - m^2 (s + u) + \\frac{5}{16}(s + u)^2 \\right\\}\n This result is completely symmetric between s and u. And, at the limit of k \\to 0, \\left| \\mathcal{M} \\right|^2_{all} = 0, which is correct since the interaction vertex is proportional to photon momentum."
  },
  {
    "objectID": "posts/AxionPhotonComptonScattering/index.html#basic-components-of-axion-photon-interaction",
    "href": "posts/AxionPhotonComptonScattering/index.html#basic-components-of-axion-photon-interaction",
    "title": "Axion-photon Compton Scattering",
    "section": "",
    "text": "The effective axion-photon lagrangian can be written as: \n\\mathcal{L}_{\\alpha\\gamma} = (\\frac{1}{2} \\partial_\\mu a \\, \\partial^\\mu a - \\frac{1}{2}m^2 a^2)\n+ (-\\frac{1}{4} F_{\\mu\\nu} F^{\\mu\\nu}) - \\frac{1}{4} g \\, a \\, F_{\\mu\\nu} \\tilde{F}^{\\mu\\nu}\n Here \\tilde{F}^{\\mu\\nu} = \\frac{1}{2}\\epsilon^{\\mu\\nu\\rho\\sigma}F_{\\rho\\sigma} is the dual of F^{\\mu\\nu}. Focus on the interaction term, break F^{\\mu\\nu} out, we have: \n\\begin{align*}\n-\\frac{1}{4} g \\, a \\, F_{\\mu\\nu} \\tilde{F}^{\\mu\\nu} &=\n-\\frac{1}{8} g \\, a (\\partial_\\mu A_\\nu - \\partial_\\nu A_\\mu)\n\\epsilon^{\\mu\\nu\\rho\\sigma} (\\partial_\\rho A_\\sigma - \\partial_\\sigma A_\\rho) \\\\\n&= - \\frac{1}{2} g \\, a \\epsilon^{\\mu\\nu\\rho\\sigma} \\partial_\\mu A^\\nu \\partial_\\rho A^\\sigma\n\\end{align*}\n Then we get the interaction vertex in the form of (in momentum space): \ni g \\epsilon^{\\mu\\nu\\rho\\sigma} k^{(1)}_\\mu k^{(2)}_\\rho\n Here k^{(1,2)} are the momentum of incoming and outcoming photons, amoung k^{(1)} and k^{(2)}, one flows into the vertex and and the other one flows out. Now recall the propagator of scalar particles and photons, we have:\n\nAxion propagator: \\frac{i}{k^2 - m^2 + i \\epsilon}\nPhoton propagator: \\frac{i \\eta_{\\mu\\nu}}{k^2 + i \\epsilon}"
  },
  {
    "objectID": "posts/AxionPhotonComptonScattering/index.html#tree-level-scattering-amplitude",
    "href": "posts/AxionPhotonComptonScattering/index.html#tree-level-scattering-amplitude",
    "title": "Axion-photon Compton Scattering",
    "section": "",
    "text": "For the lowest order of photon-axion Compton-like scattering, only two Feynman diagrams contribute, one s-channel and one u-channel:\n \nand we can write: \n\\begin{align*}\n  i\\mathcal{M}_s &= \\epsilon^{\\gamma}_{\\nu}(k) \\left( i g \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu (k+p)_\\alpha\n  \\right) \\frac{i \\eta_{\\beta\\lambda}}{(k+p)^2} \\left( i g \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  (k'+p')_\\delta k'_\\rho \\right) \\epsilon^{\\gamma'}_{\\sigma}(k') \\\\\n  \\mathcal{M}_s &= - \\frac{g^2}{(k+p)^2} \\epsilon^{\\gamma}_{\\nu}(k) \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu p_\\alpha\n   \\eta_{\\beta\\lambda} \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  p'_\\delta k'_\\rho \\epsilon^{\\gamma'}_{\\sigma}(k')\n\\end{align*}\n along with: \n\\begin{align*}\n  i\\mathcal{M}_u &= \\epsilon^{\\gamma}_{\\nu}(k) \\left( i g \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu (k-p')_\\alpha\n  \\right) \\frac{i \\eta_{\\beta\\lambda}}{(k-p')^2} \\left( i g \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  (k'-p)_\\delta k'_\\rho \\right) \\epsilon^{\\gamma'}_{\\sigma}(k') \\\\\n  \\mathcal{M}_u &= - \\frac{g^2}{(k-p')^2} \\epsilon^{\\gamma}_{\\nu}(k) \\epsilon^{\\mu\\nu\\alpha\\beta} k_\\mu p'_\\alpha\n   \\eta_{\\beta\\lambda} \\epsilon^{\\delta\\lambda\\rho\\sigma}\n  p_\\delta k'_\\rho \\epsilon^{\\gamma'}_{\\sigma}(k')\n\\end{align*}\n Then the total scattering amplitude is: \n\\begin{align*}\n\\mathcal{M} &= \\mathcal{M}_s + \\mathcal{M}_u \\\\\n&=\n- g^2 \\epsilon^{\\gamma}_{\\nu}(k) k_{\\mu} \\left( \\frac{p_\\alpha p'_\\delta}{(k+p)^2} + \\frac{p'_\\alpha p_\\delta}{(k-p')^2}\n\\right) k'_{\\rho} \\epsilon^{\\gamma'}_{\\sigma}\n(\\epsilon^{\\beta\\mu\\nu\\alpha} \\eta_{\\beta\\lambda} \\epsilon^{\\lambda\\delta\\rho\\sigma})\n\\end{align*}\n Contract and simplify this impossible expression by FORM script and complete spin sum, we can finally get: \n\\left| \\mathcal{M} \\right|^2_{all} = g^4 \\left\\{ \\frac{m^8}{16}(\\frac{1}{s} + \\frac{1}{u})^2\n- \\frac{m^4}{8}(\\frac{u}{s} + \\frac{s}{u} - 6) - m^2 (s + u) + \\frac{5}{16}(s + u)^2 \\right\\}\n This result is completely symmetric between s and u. And, at the limit of k \\to 0, \\left| \\mathcal{M} \\right|^2_{all} = 0, which is correct since the interaction vertex is proportional to photon momentum."
  },
  {
    "objectID": "posts/BornApproximationFromPathIntegral/index.html",
    "href": "posts/BornApproximationFromPathIntegral/index.html",
    "title": "Born approximation from path integral",
    "section": "",
    "text": "Born approximation is one of the most well-known perturbation method for calculating quantum scattering processes in quantum mechanics. The transition matrix can be written as: \n\\bra{p'} i \\hat{T} \\ket{p} = -i \\tilde{V}(\\bm{q}) (2 \\pi) \\, \\delta( E_{p'} - E_p )\n where \\bm{q} = \\bm{p'} - \\bm{p}.\nSurely this result can be acquired though “canonical” quantum mechanics manner, but using path integral can be super easy to get this result in a very intuitive way.\nSay, the Hamitonian of incident particle is: H = {p^2 \\over 2m} + V(x). Then immediately we can write down the Lagrangian: \nL = {1 \\over 2} m \\dot{x}^2 - V(x)\n Just a simple transform.\nRecall the definition of propagator: \n\\begin{align*}\nK &= \\int_{x(-T/2)={x_i}}^{x(T/2)={x_f}}dx \\, \\exp\\{iS\\} \\\\\n  &= \\int_{x(-T/2)={x_i}}^{x(T/2)={x_f}}dx \\, \\exp\\{iS_0\\} \\exp\\{iS_I\\}\n\\end{align*}\n Where S_0 is the free action, and S_I = - \\int dt' V(x(t')).\nAssuming V is small, we use perturbation theory by expanding \\exp to the first order: \nK=\\int_{x(-T/2)={x_i}}^{x(T/2)={x_f}}dx \\, \\exp\\{iS_0\\}\\left[1 - i\\int dt' V(x(t'))\\right] = K_0 + K_1\n\nK_0 is just the free propagator, K_1 is: \n\\begin{align*}\nK_1 &= -i\\int dt'\\int dx \\, \\exp\\{iS_0\\} V(x(t')) \\\\\n    &= -i\\int dt' \\int dx' \\, V(x') \\int_{x(-T/2)={x_i}}^{x(t')={x'}} dx \\, \\exp\\{iS_0\\} \\int_{x(t')={x'}}^{x(T/2)={x_f}} dx \\, \\exp\\{iS_0\\} \\\\\n    &= -i\\int dt' \\int dx' \\, V(x') \\, K_0(x_f,T/2;x',t') \\, K_0(x',t';x_i,-T/2)\n\\end{align*}\n Here we’ve used a trick to break the propagator into two parts, which can be interpreted as the particle traveling to point x' at time t', interacting with V, then continues its propagation, just like a vertex in QFT Feynmann diagrams.\n\n\n\nVertex\n\n\nRecall the definition of transition matrix, we have: \n\\begin{align*}\n&\\bra{p'} i \\hat{T} \\ket{p} \\\\\n=& -i\\int dx_a \\, dx_b \\braket{p', T/2|x_a}K_1(x_a,T/2;x_b,-T/2) \\braket{x_b|p,-T/2} \\\\\n=& -i\\int dx_a \\, dx_b \\, dt' \\, dx' \\,  V(x') \\times \\\\\n&\\, \\psi_{p'}^*(x_a,T/2) K_0(x_a,T/2;x',t')K_0(x',t';x_b,-T/2) \\psi_p(x_b,-T/2)\n\\end{align*}\n Note here in the definition of transition matrix, \\ket{p'} and \\ket{p} are defined under Interaction Picture, but normally propagator works under Schrödinger picture, so we have to take account of that. And here we’ve inserted two sets of position eigen states which is the canonical way of using propagators, and we get wave functions. By integrating over x_a and x_b, we get wave function at (x',t').\nThen the last thing is substituting wavefunction of momentum eigen states in to our expression: \n\\begin{align*}\n&\\bra{p'} i \\hat{T} \\ket{p} \\\\\n=& -i\\int dt' \\, dx' \\,  V(x') \\psi_{p'}^*(x',t') \\psi_p(x',t') \\\\\n=& -i\\int dt' \\, dx' \\,  V(x') \\, \\mathrm{e}^{i(\\bm{p}-\\bm{p'})x'-(E_p-E_{p'})t'} \\\\\n=& -i(2\\pi)\\,\\delta(E_p-E_{p'}) \\int dx' V(x') \\, \\mathrm{e}^{-i\\bm{q}x'} \\\\\n=& -i(2\\pi)\\,\\delta(E_p-E_{p'}) \\tilde{V}(\\bm{q})\n\\end{align*}\n Which is exactly the answer."
  },
  {
    "objectID": "posts/PortalGravity/index.html",
    "href": "posts/PortalGravity/index.html",
    "title": "Gravity With Portal",
    "section": "",
    "text": "Recently, I saw this interesting youtube video, at the first glance, I realized it is just solving the classical gravitational equation maybe under a specific boundary condition? It’s too fun to not try to do it by myself first, then watch the full video. So I tried to qucikly simulate it using Julia, and analyze the result.\nTo simplify the problem, let there be no mass in the space, gravitational field satisfies Laplace equation: \n\\nabla^2 \\varphi = 0\n Consider a box, we set gravitational potential of the top to 0, the bottom to 100, and apply periodic boundary on left and right. This setting itself is just like what we do when we calculate the electrical field between two charged infinitely large metal plates, they satisfy the same equation so for classical gravity they do no different.\nOne can use finite elements method or finite difference method to calculate this simple question, to keep it simple I decided to just write a simple finite difference equation constructor in Julia. Then, the portal is actually just remapping the neighbors. Laplace equation is local, for those grid which is next to the portal, we trace their neighbor though the portal, very naive & simple.\n\n\nCode\nusing LinearAlgebra\nusing SparseArrays\nusing Plots\n\nconst X_GRIDS     = 1000\nconst Y_GRIDS     = 1000\nconst GRID_WIDTH  = 1\n\nconst PORTAL_1    = CartesianIndices((350:650, 150:150))\nconst PORTAL_2    = CartesianIndices((350:650, 151:151))\nconst PORTAL_3    = CartesianIndices((350:650, 850:850))\nconst PORTAL_4    = CartesianIndices((350:650, 851:851))\n\nconst PAIR_11      = (PORTAL_1, PORTAL_4)\nconst PAIR_12      = (PORTAL_4, PORTAL_1)\nconst PAIR_21      = (PORTAL_2, PORTAL_3)\nconst PAIR_22      = (PORTAL_3, PORTAL_2)\n\nconst PORTAL_PAIRS = [PAIR_11, PAIR_12, PAIR_21, PAIR_22]\n\nfunction build_portal_map()\n    mapping = Dict{CartesianIndex{2}, CartesianIndex{2}}()\n\n    pairs = [\n        (PORTAL_1, PORTAL_4),\n        (PORTAL_4, PORTAL_1),\n        (PORTAL_2, PORTAL_3),\n        (PORTAL_3, PORTAL_2)\n    ]\n    \n    for (src_range, dst_range) in pairs\n        for (src, dst) in zip(src_range, dst_range)\n            mapping[src] = dst\n        end\n    end\n    return mapping\nend\n\nconst PORTAL_MAP = build_portal_map()\nfunction boundary1((i, j))\n  if j &lt; 1 \n    return 0\n  elseif j &gt; Y_GRIDS\n    return 100\n  else\n    return nothing\n  end\nend\n\nfunction periodic_x(x)\n  if x &lt; 1\n    return X_GRIDS\n  elseif x &gt; X_GRIDS\n    return 1\n  else\n    return x\n  end\nend\n\ncis = CartesianIndices((1:X_GRIDS, 1:Y_GRIDS))\nids = LinearIndices(cis)\nn_grids = length(ids)\n\nfunction fill_eq()\n  I = Int[]\n  J = Int[]\n  V = Float64[]\n  ρs = fill(0.0, n_grids)\n  for ci in cis\n    x, y = Tuple(ci)\n    push!(I, ids[x, y])\n    push!(J, ids[x, y])\n    push!(V, 4.0)\n\n    for (i, j) in ((x+1, y), (x-1, y), (x, y+1), (x, y-1))\n      \n      b1 = boundary1((i, j))\n      if !isnothing(b1)\n        ρs[ids[x, y]] += b1\n        continue\n      end\n\n      i = periodic_x(i)\n\n      cid = CartesianIndex(i, j)\n      if haskey(PORTAL_MAP, cid)\n        i, j = Tuple(PORTAL_MAP[cid])\n      end\n      push!(I, ids[x,y])\n      push!(J, ids[i, j])\n      push!(V, -1.0)\n    end\n  end\n  m = sparse(I, J, V, n_grids, n_grids)\n  return m, ρs\nend\n\nfunction get_result()\n  A, b = fill_eq()\n  u = A \\ b\n  u_grid = reshape(u, X_GRIDS, Y_GRIDS)\n  return u_grid\nend\n\n\nFor this portal configuration, we will get the following result:  The gravitational field between the portals is quite weak, the field is identical to what one would see if one places 2 connected metal plates between two large charged metal plates! Two metal plates will share the same potential, and for a symmetrical system like this, they will share the potential of zero, and will shield out the field.\nBut portal can face different directions, if we flip one portal’s orientation, will the field stay the same? Actually it will. If one go though it carefully, it is not hard to imagine the portal just curves our experimental plane, it pulls up to segments on the plane and stick them together, make it a ring growing out of the flat paper. No matter how you twist the way you stick them together, the sticky boundary will topologically be at the center between the upper and lower boundary, which make the field identical."
  }
]